# 2장 객체지향설계


## 목차

[[toc]]

 - **추상화** : 각 연산이 무슨 일을 하는 지는 지정하지만 어떻게 하는지는 몰라도 됨
    * 즉, 내부 구현을 몰라도 외부 기능을 쉽게 사용할 수 있게함     

 - **캡슐화** : 시스템의 내부 구현 세부사항을 외부로 드러내지 않는 것
    * 외부 인터페이스만 지켜주면 내부를 어떻게 구현하든 상관 없음   

 - **모듈화** : 독립된 기능적 단위의 구성요소들

## 객체지향 3대 요소

**캡슐화(Encapsulation)**

객체가 구현된 방식의 세부정보를 사용자로부터 숨기면서 유지하는 방식   
사용자는 객체의 공개 인터페이스(public)을 통해 접근할 수 있다.

C++에서는 접근지정자를 통해 캡슐화를 구현한다 - Public, Private

- 클래스의 재사용성과 유지보수 측면에서 많은 이점이 있다.
1. 캡슐화를 통해 내부 구현을 몰라도 쉽게 사용할 수 있다.
    - ex) `std::string`, `std::vector`

2. 캡슐화를 통해 데이터 보호와 오용을 방지할 수 있다.
    - ex) 범위 검사, 배열의 범위 초과 접근

**상속성(Inheritance)**

이미 정의 된 부모 클래스의 모든 속성과 연산을 자식 클래스가 물려 받음.

1. 부모의 모든 속성과 연상을 자신이 사용 가능
2. 자식은 부모로부터 받은 속성과 연산 외에 새로운 속성과 연산을 추가할 수 있음
3. 속성과 연산을 공유할 수 있기 때문에 재사용성을 증대시킴

**다형성(Polymoriphism)**

객체가 연산을 수행해야 할 때 자신(객채)이 가지고 있는 방법으로 응답하는 것

1. 변수의 타입에 따라 호출 되는 함수를 결정
2. 오버라이딩 - 상속받은 함수를 그대로 사용하지 않고 수정해서 사용 (함수명,인자,리턴값은 같아야 함)

::: tip

따라서, 기본 클래스 포인터를 재활용해 파생클래스를 연결시킬 수 있음   
(함수 동적바인딩 수행)

:::

## 정적바인딩(Static binding) vs 동적바인딩(Dynamic binding)

::: tip 바인딩?

함수 호출하는 부분에 해당 함수의 메모리 번지를 연결시키는 것

:::

- 정적바인딩(일반함수)
  - 컴파일 시간에 함수 주소가 결정되어 바인딩 됨

- 동적바인딩(가상함수) - virtual 함수
  - 실행파일을 만들 때 바인딩 없이 보류 상태로 둠
  - 점프할 메모리 공간(4byte)을 가지고 있다가 런타임에 결정
    - 단점 : **타입체킹**으로 인한 수행 속도 저하 


## 가상소멸자

- 가상함수(virtual)를 사용했다면 기본 클래스의 소멸자는 가상함수로 선언해야만 한다.
  - 그렇지 않으면 기본 소멸자만 호출 되어 **메모리 누수** 현상이 생긴다.

***
_**Date 2020-08-06**_
***
