# 2장 객체지향설계


## Table Of Contents

[[toc]]

 - **추상화** : 각 연산이 무슨 일을 하는 지는 지정하지만 어떻게 하는지는 몰라도 됨
    * 즉, 내부 구현을 몰라도 외부 기능을 쉽게 사용할 수 있게함     

 - **캡슐화** : 시스템의 내부 구현 세부사항을 외부로 드러내지 않는 것
    * 외부 인터페이스만 지켜주면 내부를 어떻게 구현하든 상관 없음   

 - **모듈화** : 독립된 기능적 단위의 구성요소들

## 객체지향 3대 요소

**캡슐화(Encapsulation)**

객체가 구현된 방식의 세부정보를 사용자로부터 숨기면서 유지하는 방식   
사용자는 객체의 공개 인터페이스(public)을 통해 접근할 수 있다.

C++에서는 접근지정자를 통해 캡슐화를 구현한다 - Public, Private

- 클래스의 재사용성과 유지보수 측면에서 많은 이점이 있다.
1. 캡슐화를 통해 내부 구현을 몰라도 쉽게 사용할 수 있다.
    - ex) `std::string`, `std::vector`

2. 캡슐화를 통해 데이터 보호와 오용을 방지할 수 있다.
    - ex) 범위 검사, 배열의 범위 초과 접근

**상속성(Inheritance)**

이미 정의 된 부모 클래스의 모든 속성과 연산을 자식 클래스가 물려 받음.

1. 부모의 모든 속성과 연상을 자신이 사용 가능
2. 자식은 부모로부터 받은 속성과 연산 외에 새로운 속성과 연산을 추가할 수 있음
3. 속성과 연산을 공유할 수 있기 때문에 재사용성을 증대시킴

**다형성(Polymoriphism)**

객체가 연산을 수행해야 할 때 자신(객채)이 가지고 있는 방법으로 응답하는 것

**1.** 변수의 타입에 따라 호출 되는 함수를 결정
**2.** 오버라이딩 - 상속받은 함수를 그대로 사용하지 않고 수정해서 사용 (함수명,인자,리턴값은 같아야 함)

::: tip

따라서, 기본 클래스 포인터를 재활용해 파생클래스를 연결시킬 수 있음   
(함수 동적바인딩 수행)

:::

## 정적바인딩(Static binding) vs 동적바인딩(Dynamic binding)

::: tip 바인딩?

함수 호출하는 부분에 해당 함수의 메모리 번지를 연결시키는 것

:::

- **정적바인딩(일반함수)**
  - 컴파일 시간에 함수 주소가 결정되어 바인딩 됨

- **동적바인딩(가상함수)** - virtual 함수
  - 실행파일을 만들 때 바인딩 없이 보류 상태로 둠
  - 점프할 메모리 공간(4byte)을 가지고 있다가 런타임에 결정
    - 단점 : **타입체킹**으로 인한 수행 속도 저하 


## 가상소멸자

- 가상함수(virtual)를 사용했다면 기본 클래스의 소멸자는 **가상함수**로 선언해야만 한다.
  - 그렇지 않으면 기본 소멸자만 호출 되어 **메모리 누수** 현상이 생긴다.

## 템플릿

### **함수 템플릿**

```cpp
template <template T>
T genericMin(T a, T b){
  return (a < b ? a : b);
}
```

### **클래스 템플릿**

 C++은 템플릿화된 클래스 또한 허용한다. 이것은 많은 다른 타입이 적용될 수 있는 하나의 자료구조를 제공한다. **(매우 강력!)**

### **템플릿화된 매개변수**

 클래스 템플릿의 인스턴스화 시 실제 매개변수는 템플릿된 타입이 될 수 있다.

```cpp
  BasicVector<BasicVector<int> > xv(5);
  //..
  xv[2][8] = 15;
```

## 예외 (Exception)
 > 프로그램 실행 동안 일어나는 예기치 못한 사건들

### **예외 처리**
 > 예외를 처리하는 과정

```cpp
if (b == 0) // 나누는 수가 0이라면,
  cout << "나누는 수가 0이 될 수 없습니다." << endl;
else
  cout << a << "를 " << b << "로 나눈 몫은 " << a/b << "입니다." << endl;
return 0;
```
이런 방식의 예외처리는 똑같은 예외 발생 시 마다 똑같이 처리해줘야 하기 때문에
코드가 늘어나고 예외 처리의 구분이 명확하지 않다.

따라서 아래 방법을 사용하면 좋다
### try-catch , throw 방법
* 기본 형태
```cpp
try { // 예외 발생
    if (예외 조건) throw 예외 객체; // 예외를 던지는 영역
} catch (예외 객체) { // 던져진 예외를 잡는 영역
    // 예외 처리 영역
}
```

* 응용 예시
```cpp
try {
  if (b == 0) throw b;
    cout << a << "를 " << b << "로 나눈 몫은 " << a/b << "입니다." << endl;
} catch (int exception) {
    cout << "예외 발생, 나누는 수는 " << b << "가 될 수 없습니다." << endl;
}
return 0;
```
1. b가 0이면 throw로 b를 던져버림
2. 던져진 b는 exception에 들어가게 됨
3. 이것을 catch가 잡아서 처리

### 함수 예외 처리
```cpp
void func(int a, int b)
{
if (b == 0) throw b;

int main(){...
  try {
    func(a, b);
  } catch (int exception) {
    cout << "예외 발생, 나누는 수는 " << b << "가 될 수 없습니다." << endl;
  }
  return 0;
}
```
함수 내에서 예외를 던지고 있으나 함수 밖에 예외 처리 영역이 있기 때문에 호출된
영역으로 예외를 전달한다.   
전달된 데이터를 catch가 잡아서 처리한다. (기본 데이터형 뿐만 아니라 객체도 가능)



***
_**Last-Modified Date 2020-08-07**_
***
