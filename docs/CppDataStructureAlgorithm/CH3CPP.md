
# 3장 배열, 링크드 리스트 그리고 재귀

  
  

## Table Of Contents

  

[[toc]]

  

## 배열로 행렬 동적 할당

  

* 배열의 배열 동적 할당

  

```cpp

int** M =  new  int*[n];

for(int i=0; i<n; i++>)

M[i] =  new  int[m];

```

* 반환

```cpp

for(int i=0; i<n; i++)

delete[]  M[i];

delete[] M;

```

  

## STL 벡터로 행렬 구현

  

::: tip 벡터를 이용하면 배열을 이용한 방법보다 조금 더 우아하게 행렬을 처리 할수 있다.

vector클래스 생성자의 특성을 이용하자 (두번째 인수 사용)

:::

  

* 벡터의 n x M 행렬 할당

```cpp

vector< vector<int> > M(n, vector<int>(M));

cout <<  M[i][j] << endl;

```

  

## 단일 링크드 리스트

배열과는 다른 시퀀스를 구현할 대안 중 하나인 단일 링크드 리스트

  

* next 포인터 : 다른 노드에 대한 **링크** 또는 **포인터**

  

* 배열 처럼 고정된 크기를 갖는 것이 아닌 노드를 추가하거나 삭제함으로써 사이즈를 재조정할 수 있다.

* 마지막 노드를 삭제하려면 전체리스트를 순회하는 것이 필요해 긴 수행시간을 요구한다.

  

## 이중 링크드 리스트
빠른 접근과 삭제를 위해 양방향 접근으로 설계했다. 원소 멤버 이외에 **next링크**와 **prev링크**를 가진다.

* 양 끝 **head**와 **tail**에 **header**와 **trailer**를 추가함으로써 예외를	 두지 않을 수 있다.

*  삽입, 삭제를 빠르게 수행 할 수 있다.

## 재귀
재귀는 반복적인 작업을 수행하는데 강력하다.

*  선형 재귀
	+	선형재귀는 호출이 발생할 때마다 최대 하나의 재귀 호출이 이루어지는 함수이다.
* 이진 재귀
	*  알고리즘이 2개의 재귀 호출을 만드는 경우이다.

***
_**Last-Modified Date 2020-08-07**_
***
